# Flujo de Estados de Planes - Happy Dreamers

## Documentaci√≥n del Sistema de Gesti√≥n de Estados de Planes

**Fecha de creaci√≥n:** 2025-01-24
**Versi√≥n:** 1.0
**Autor:** Sistema Happy Dreamers

---

## üìã √çndice

1. [Resumen Ejecutivo](#resumen-ejecutivo)
2. [Estados de Planes](#estados-de-planes)
3. [Flujo de Transiciones](#flujo-de-transiciones)
4. [Casos de Uso](#casos-de-uso)
5. [Implementaci√≥n T√©cnica](#implementaci√≥n-t√©cnica)
6. [Ejemplos Pr√°cticos](#ejemplos-pr√°cticos)
7. [Validaciones y Reglas de Negocio](#validaciones-y-reglas-de-negocio)

---

## üìù Resumen Ejecutivo

El sistema de planes de Happy Dreamers maneja tres estados principales para cada plan: **borrador**, **activo** y **completado**. Este documento describe el ciclo de vida completo de un plan y las reglas que gobiernan las transiciones entre estados.

### Principios Fundamentales

1. **Un solo plan activo**: Solo puede existir un plan activo por ni√±o en cualquier momento
2. **Progresi√≥n autom√°tica**: Al aplicar un nuevo plan, el anterior se marca como completado
3. **Reactivaci√≥n inteligente**: Si se elimina un plan activo, el sistema reactiva autom√°ticamente el plan anterior
4. **Trazabilidad completa**: Todos los cambios de estado quedan registrados con informaci√≥n de auditor√≠a

---

## üîÑ Estados de Planes

### 1. Borrador (`borrador`)

**Descripci√≥n**: Estado inicial de todo plan reci√©n generado por el admin.

**Caracter√≠sticas**:
- Plan generado pero no aplicado al usuario
- Visible solo para el admin
- El usuario NO ve este plan en su interfaz
- Puede ser editado, eliminado o aplicado

**Cu√°ndo se crea**:
- Al generar Plan 0 (inicial)
- Al generar Plan N (basado en eventos)
- Al generar Plan N.1 (refinamiento con transcript)

**Acciones permitidas**:
- ‚úÖ Editar (PUT `/api/consultas/plans/[id]`)
- ‚úÖ Eliminar (DELETE `/api/consultas/plans/[id]`)
- ‚úÖ Aplicar (PATCH `/api/consultas/plans/[id]`)
- ‚ùå No visible para el usuario padre

---

### 2. Activo (`activo`)

**Descripci√≥n**: Plan aplicado y actualmente en uso por el usuario.

**Caracter√≠sticas**:
- Plan principal que el usuario ve y sigue
- Solo puede haber UNO por ni√±o
- Visible en el dashboard del usuario
- El admin puede verlo y editarlo

**Cu√°ndo se activa**:
- Al aplicar un plan en estado borrador (PATCH)
- Al reactivarse despu√©s de eliminar el plan activo actual

**Acciones permitidas**:
- ‚úÖ Ver (usuario y admin)
- ‚úÖ Editar (admin √∫nicamente)
- ‚úÖ Eliminar (admin √∫nicamente - reactiva el anterior)
- ‚ùå NO se puede aplicar de nuevo (ya est√° activo)

**Transiciones autom√°ticas**:
- ‚Üí `completado`: Cuando se aplica un nuevo plan
- ‚Üí Eliminado: Cuando el admin lo elimina (reactiva el anterior)

---

### 3. Completado (`completado`)

**Descripci√≥n**: Plan que fue activo pero ya fue reemplazado por uno m√°s reciente.

**Caracter√≠sticas**:
- Plan hist√≥rico para referencia
- Visible en el historial del usuario
- No se puede editar
- Mantiene toda la informaci√≥n de auditor√≠a

**Cu√°ndo se marca como completado**:
- Al aplicar un nuevo plan (el anterior activo ‚Üí completado)
- Autom√°ticamente cuando un plan activo es reemplazado

**Acciones permitidas**:
- ‚úÖ Ver (usuario y admin - historial)
- ‚úÖ Eliminar (admin √∫nicamente)
- ‚ùå NO se puede editar
- ‚ùå NO se puede reactivar manualmente (solo autom√°ticamente al eliminar el activo)

**Transiciones posibles**:
- ‚Üí `activo`: Solo cuando se elimina el plan activo actual (reactivaci√≥n autom√°tica)

---

## üîÄ Flujo de Transiciones

### Diagrama de Estados

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   BORRADOR   ‚îÇ ‚Üê Plan reci√©n generado
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îÇ PATCH /api/consultas/plans/[id]
       ‚îÇ (Aplicar plan)
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    ACTIVO    ‚îÇ ‚Üê Plan en uso actual
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îÇ Nuevo plan aplicado
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  COMPLETADO  ‚îÇ ‚Üê Plan hist√≥rico
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îÇ Plan activo eliminado
       ‚îÇ (Reactivaci√≥n autom√°tica)
       ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                        ‚îÇ
                        ‚ñº
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ    ACTIVO    ‚îÇ ‚Üê Reactivado
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üíº Casos de Uso

### Caso 1: Generar y Aplicar Primer Plan

**Escenario**: Admin genera Plan 0 para un nuevo ni√±o

**Flujo**:

1. Admin genera Plan 0 ‚Üí Estado: `borrador`
2. Plan NO visible para el usuario
3. Admin revisa y aplica el plan ‚Üí Estado: `activo`
4. Usuario ahora ve el plan en su dashboard

**Estados en base de datos**:

```javascript
// Despu√©s de generar
{
  _id: "plan_001",
  planNumber: 0,
  planVersion: "0",
  status: "borrador", // ‚Üê Estado inicial
  childId: "child_123",
  createdAt: "2025-01-24T10:00:00Z"
}

// Despu√©s de aplicar
{
  _id: "plan_001",
  planNumber: 0,
  planVersion: "0",
  status: "activo", // ‚Üê Estado cambiado
  appliedBy: "admin_456",
  appliedAt: "2025-01-24T10:30:00Z",
  childId: "child_123"
}
```

---

### Caso 2: Aplicar Nuevo Plan (Progresi√≥n Natural)

**Escenario**: Admin genera Plan 1 basado en eventos, reemplazando Plan 0

**Flujo**:

1. Usuario tiene Plan 0 activo
2. Admin genera Plan 1 ‚Üí Estado: `borrador`
3. Admin aplica Plan 1:
   - Plan 0: `activo` ‚Üí `completado`
   - Plan 1: `borrador` ‚Üí `activo`
4. Usuario ve Plan 1, Plan 0 queda en historial

**Estados en base de datos**:

```javascript
// Antes de aplicar Plan 1
[
  { _id: "plan_001", planVersion: "0", status: "activo" }  // Plan actual
]

// Despu√©s de aplicar Plan 1
[
  { _id: "plan_001", planVersion: "0", status: "completado" }, // ‚Üê Marcado como completado
  { _id: "plan_002", planVersion: "1", status: "activo" }      // ‚Üê Nuevo plan activo
]
```

**C√≥digo ejecutado**:

```typescript
// 1. Marcar planes activos anteriores como completados
await plansCollection.updateMany(
  {
    childId: planToApply.childId,
    status: "activo",
    _id: { $ne: new ObjectId(planId) }
  },
  {
    $set: {
      status: "completado",
      updatedAt: new Date()
    }
  }
)

// 2. Activar el nuevo plan
await plansCollection.updateOne(
  { _id: new ObjectId(planId) },
  {
    $set: {
      status: "activo",
      appliedBy: new ObjectId(session.user.id),
      appliedAt: new Date()
    }
  }
)
```

---

### Caso 3: Eliminar Plan Activo (Reactivaci√≥n)

**Escenario**: Admin elimina el Plan 1 activo por error

**Flujo**:

1. Usuario tiene Plan 1 activo
2. Admin elimina Plan 1
3. Sistema busca el plan anterior (Plan 0)
4. Sistema reactiva Plan 0: `completado` ‚Üí `activo`
5. Usuario vuelve a ver Plan 0

**Estados en base de datos**:

```javascript
// Antes de eliminar Plan 1
[
  { _id: "plan_001", planVersion: "0", status: "completado" },
  { _id: "plan_002", planVersion: "1", status: "activo" }  // ‚Üê A eliminar
]

// Despu√©s de eliminar Plan 1
[
  {
    _id: "plan_001",
    planVersion: "0",
    status: "activo", // ‚Üê Reactivado autom√°ticamente
    reactivatedAt: "2025-01-24T11:00:00Z",
    reactivatedBy: "admin_456",
    reactivatedReason: "Plan 1 eliminado"
  }
  // plan_002 ya no existe (eliminado)
]
```

**C√≥digo de reactivaci√≥n**:

```typescript
// Funci√≥n de comparaci√≥n de versiones (maneja refinamientos como 1.1, 2.1)
const compareVersions = (versionA: string, versionB: string): number => {
  const parseVersion = (v: string) => {
    const parts = v.split('.')
    const major = parseInt(parts[0]) || 0
    const minor = parseInt(parts[1]) || 0
    return { major, minor }
  }

  const a = parseVersion(versionA)
  const b = parseVersion(versionB)

  if (a.major !== b.major) {
    return b.major - a.major // Mayor n√∫mero primero
  }
  return b.minor - a.minor // Mayor refinamiento primero
}

// Ordenar planes por versi√≥n (de mayor a menor)
const sortedPlans = allPlans.sort((a, b) =>
  compareVersions(a.planVersion, b.planVersion)
)

// El primer plan es el m√°s reciente (anterior al eliminado)
const previousPlan = sortedPlans[0]

if (previousPlan) {
  // Reactivar el plan anterior
  await collection.updateOne(
    { _id: previousPlan._id },
    {
      $set: {
        status: "activo",
        reactivatedAt: new Date(),
        reactivatedBy: new ObjectId(session.user.id),
        reactivatedReason: `Plan ${planToDelete.planVersion} eliminado`
      }
    }
  )
}
```

---

### Caso 4: Refinamiento con Transcript (Plan N.1)

**Escenario**: Admin genera Plan 1.1 (refinamiento de Plan 1) basado en consulta

**Flujo**:

1. Usuario tiene Plan 1 activo
2. Hay una consulta nueva con transcript
3. Admin genera Plan 1.1 ‚Üí Estado: `borrador`
4. Admin aplica Plan 1.1:
   - Plan 1: `activo` ‚Üí `completado`
   - Plan 1.1: `borrador` ‚Üí `activo`
5. Usuario ve Plan 1.1

**Estados en base de datos**:

```javascript
// Antes de aplicar Plan 1.1
[
  { _id: "plan_001", planVersion: "0", status: "completado" },
  { _id: "plan_002", planVersion: "1", status: "activo" }
]

// Despu√©s de aplicar Plan 1.1
[
  { _id: "plan_001", planVersion: "0", status: "completado" },
  { _id: "plan_002", planVersion: "1", status: "completado" }, // ‚Üê Marcado como completado
  { _id: "plan_003", planVersion: "1.1", status: "activo" }   // ‚Üê Refinamiento activo
]
```

---

### Caso 5: M√∫ltiples Eliminaciones con Refinamientos

**Escenario**: Usuario tiene historial complejo (Plan 0, 1, 1.1, 2) y se elimina Plan 2 activo

**Flujo**:

1. Estado inicial:
   - Plan 0: `completado`
   - Plan 1: `completado`
   - Plan 1.1: `completado`
   - Plan 2: `activo`

2. Admin elimina Plan 2

3. Sistema ordena por versi√≥n:
   - 2 (eliminado)
   - 1.1 (m√°s reciente disponible) ‚Üê Este se reactiva
   - 1
   - 0

4. Sistema reactiva Plan 1.1: `completado` ‚Üí `activo`

**L√≥gica de ordenamiento**:

```javascript
// Comparaci√≥n de versiones
compareVersions("2", "1.1")   // ‚Üí 2 es mayor (2.0 vs 1.1)
compareVersions("1.1", "1")   // ‚Üí 1.1 es mayor (1.1 vs 1.0)
compareVersions("1", "0")     // ‚Üí 1 es mayor (1.0 vs 0.0)

// Resultado: [2, 1.1, 1, 0]
// Al eliminar Plan 2, se reactiva 1.1 (siguiente en la lista)
```

---

## üîß Implementaci√≥n T√©cnica

### Endpoints Modificados

#### 1. PATCH `/api/consultas/plans/[id]` - Aplicar Plan

**Funci√≥n**: Cambiar plan de `borrador` a `activo`

**L√≥gica implementada**:

```typescript
export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  // 1. Verificar que el plan est√© en borrador
  if (planToApply.status !== "borrador") {
    return NextResponse.json(
      { error: "Solo se pueden aplicar planes en estado borrador" },
      { status: 400 }
    )
  }

  // 2. Marcar todos los planes activos como completados
  await plansCollection.updateMany(
    {
      childId: planToApply.childId,
      userId: planToApply.userId,
      status: "activo",
      _id: { $ne: new ObjectId(planId) }
    },
    {
      $set: {
        status: "completado",
        updatedAt: new Date()
      }
    }
  )

  // 3. Activar el plan actual
  await plansCollection.updateOne(
    { _id: new ObjectId(planId) },
    {
      $set: {
        status: "activo",
        updatedAt: new Date(),
        appliedBy: new ObjectId(session.user.id),
        appliedAt: new Date()
      }
    }
  )

  return NextResponse.json({
    success: true,
    message: "Plan aplicado correctamente. Los planes anteriores han sido marcados como completados."
  })
}
```

---

#### 2. DELETE `/api/consultas/plans/[id]` - Eliminar Plan

**Funci√≥n**: Eliminar un plan y reactivar el anterior si era activo

**L√≥gica implementada**:

```typescript
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  // 1. Obtener el plan a eliminar
  const planToDelete = await collection.findOne({ _id: new ObjectId(planId) })

  // 2. Si es activo, buscar el plan anterior para reactivarlo
  let reactivatedPlan = null
  if (planToDelete.status === "activo") {
    // Obtener todos los planes del mismo ni√±o (excepto el que se va a eliminar)
    const allPlans = await collection.find({
      childId: planToDelete.childId,
      userId: planToDelete.userId,
      _id: { $ne: new ObjectId(planId) }
    }).toArray()

    // Ordenar por versi√≥n (mayor a menor)
    const sortedPlans = allPlans.sort((a, b) =>
      compareVersions(a.planVersion, b.planVersion)
    )

    // El primer plan es el m√°s reciente
    const previousPlan = sortedPlans[0]

    if (previousPlan) {
      // Reactivar el plan anterior
      await collection.updateOne(
        { _id: previousPlan._id },
        {
          $set: {
            status: "activo",
            reactivatedAt: new Date(),
            reactivatedBy: new ObjectId(session.user.id),
            reactivatedReason: `Plan ${planToDelete.planVersion} eliminado`
          }
        }
      )
      reactivatedPlan = previousPlan
    }
  }

  // 3. Eliminar el plan original
  await collection.deleteOne({ _id: new ObjectId(planId) })

  return NextResponse.json({
    success: true,
    message: "Plan eliminado correctamente",
    reactivated: reactivatedPlan ? {
      planId: reactivatedPlan._id,
      planVersion: reactivatedPlan.planVersion
    } : null
  })
}
```

---

### Funci√≥n de Comparaci√≥n de Versiones

```typescript
/**
 * Compara versiones de planes considerando refinamientos
 * Ejemplos:
 *   - "2" > "1.1" (2.0 > 1.1)
 *   - "1.1" > "1" (1.1 > 1.0)
 *   - "1" > "0" (1.0 > 0.0)
 */
const compareVersions = (versionA: string, versionB: string): number => {
  const parseVersion = (v: string) => {
    const parts = v.split('.')
    const major = parseInt(parts[0]) || 0
    const minor = parseInt(parts[1]) || 0
    return { major, minor }
  }

  const a = parseVersion(versionA)
  const b = parseVersion(versionB)

  // Comparar n√∫mero mayor (plan base)
  if (a.major !== b.major) {
    return b.major - a.major // Mayor n√∫mero primero
  }

  // Si el n√∫mero mayor es igual, comparar refinamiento
  return b.minor - a.minor // Mayor refinamiento primero
}
```

**Ejemplos de uso**:

```javascript
compareVersions("2", "1.1")   // ‚Üí 1 (2 > 1.1)
compareVersions("1.1", "1")   // ‚Üí 1 (1.1 > 1)
compareVersions("1", "0")     // ‚Üí 1 (1 > 0)
compareVersions("1.1", "1.1") // ‚Üí 0 (iguales)
compareVersions("0", "1")     // ‚Üí -1 (0 < 1)
```

---

## ‚úÖ Validaciones y Reglas de Negocio

### Reglas de Estado

1. **Solo un plan activo**: Sistema garantiza que solo existe un plan activo por ni√±o
2. **Progresi√≥n autom√°tica**: Al aplicar plan, el anterior se marca como completado autom√°ticamente
3. **Reactivaci√≥n inteligente**: Al eliminar plan activo, se reactiva el m√°s reciente disponible
4. **Auditor√≠a completa**: Todos los cambios quedan registrados con usuario, fecha y raz√≥n

### Validaciones en PATCH (Aplicar)

```typescript
// ‚ùå No se puede aplicar un plan que no sea borrador
if (planToApply.status !== "borrador") {
  return error("Solo se pueden aplicar planes en estado borrador")
}

// ‚úÖ Se marcan como completados todos los planes activos anteriores
// ‚úÖ Se activa el plan seleccionado
// ‚úÖ Se registra qui√©n y cu√°ndo lo aplic√≥
```

### Validaciones en DELETE (Eliminar)

```typescript
// ‚úÖ Se puede eliminar cualquier plan (borrador, activo, completado)
// ‚úÖ Si es activo, se reactiva autom√°ticamente el anterior
// ‚úÖ Si no hay plan anterior, el ni√±o queda sin plan activo
// ‚úÖ Se registra la reactivaci√≥n con fecha, usuario y raz√≥n
```

---

## üìä Ejemplos Pr√°cticos con Datos Reales

### Ejemplo 1: Flujo Completo de Vida de un Ni√±o

**Timeline**:

```
D√≠a 1:
- Admin genera Plan 0 ‚Üí borrador
- Admin aplica Plan 0 ‚Üí activo

D√≠a 7:
- Admin genera Plan 1 (eventos) ‚Üí borrador
- Admin aplica Plan 1 ‚Üí activo
  Plan 0 ‚Üí completado (autom√°tico)

D√≠a 10:
- Admin genera Plan 1.1 (refinamiento) ‚Üí borrador
- Admin aplica Plan 1.1 ‚Üí activo
  Plan 1 ‚Üí completado (autom√°tico)

D√≠a 14:
- Admin elimina Plan 1.1 por error
  Plan 1.1 ‚Üí eliminado
  Plan 1 ‚Üí activo (reactivaci√≥n autom√°tica)
```

**Estado final de base de datos**:

```javascript
[
  {
    _id: "plan_001",
    planVersion: "0",
    status: "completado",
    createdAt: "2025-01-01",
    appliedAt: "2025-01-01"
  },
  {
    _id: "plan_002",
    planVersion: "1",
    status: "activo", // ‚Üê Reactivado
    createdAt: "2025-01-07",
    appliedAt: "2025-01-07",
    reactivatedAt: "2025-01-14",
    reactivatedBy: "admin_456",
    reactivatedReason: "Plan 1.1 eliminado"
  }
  // plan_003 (Plan 1.1) fue eliminado
]
```

---

### Ejemplo 2: M√∫ltiples Refinamientos

**Escenario**: Plan con varias iteraciones de refinamiento

```
Plan 0 ‚Üí completado
Plan 1 ‚Üí completado
Plan 1.1 ‚Üí completado
Plan 2 ‚Üí completado
Plan 2.1 ‚Üí activo ‚Üê Usuario ve este
```

**Si se elimina Plan 2.1**:

```javascript
// Sistema ordena: [2.1 (eliminar), 2, 1.1, 1, 0]
// Reactiva el siguiente: Plan 2

Plan 0 ‚Üí completado
Plan 1 ‚Üí completado
Plan 1.1 ‚Üí completado
Plan 2 ‚Üí activo ‚Üê Reactivado autom√°ticamente
// Plan 2.1 eliminado
```

---

## üéØ Beneficios del Sistema

1. **Simplicidad para el usuario**: Solo ve un plan activo, sin confusi√≥n
2. **Historial completo**: Todos los planes anteriores disponibles para referencia
3. **Recuperaci√≥n ante errores**: Eliminaci√≥n accidental no pierde progreso
4. **Trazabilidad total**: Auditor√≠a completa de cambios y reactivaciones
5. **Consistencia garantizada**: Imposible tener m√∫ltiples planes activos

---

## üìö Referencias T√©cnicas

### Archivos Modificados

- `app/api/consultas/plans/[id]/route.ts`: L√≥gica de PATCH (aplicar) y DELETE (eliminar con reactivaci√≥n)
- `app/api/consultas/plans/route.ts`: Generaci√≥n de planes en estado borrador

### Modelos de Datos

- Ver `types/models.ts` para definici√≥n completa de `ChildPlan`
- Estados: `"borrador" | "activo" | "completado" | "superseded" | "archived"`

---

**Fin del documento**
